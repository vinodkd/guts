<!-- fpw_workshop_screenplay.md -->
Screenplay for the FPW Workshop video
=====================================

Outline
------

- brief history and why
- explain the concept
- glimpse of future
- size
	- evolving into the marble run model
	- program size
	- data size
	- program data convergence
	- thus size


Screenplay
----------

1. Intro 
	- OS: Headshot
	- VO: *intro of me and the project*
		- Hi my name is ....
		- i'm going to be talking about a project i've been working on for the past few years
		- I call it - somewhat grandiosely - the Grand unified theory of software
1.  Agenda
	- VO: << Set the agenda >>
	- OS: 
		- the idea
		- where i am in the project
		- what i'll be talking about today
		- no code demo (well, a small one, but thats not the meat)
1.  Code desc
	- Voiceover: *have you used these words when you develop software?*
	- on screen: word clould like brittle, flexible, large, architecture, design
1. ... IRL
	- VO: *... and you're using them because you have a physical parallel?*
	- on screen: pictures of use of those words in real life setting
1. call to authority
	- VO: *we use a lot of physical terms when we talk about software and the process by which we build it. two famous examples I can think of are..*
	- on screen: show alan kay's talk and rich hickey's braided tower pictures
1. 
	- VO: *so what if we actually took that to the logical end and created a physics for software?*
	- on screen: show lego with print hello world on it
1. 
	- VO: *of course, this wouldnt be exactly like regular physics because software is not physical*
	- OS: show matrix code and other examples of screen code
1. 
	- VO: *For example, physical construction has hard limits*
	- OS: show tolerance in a mechanical drawing and a bridge max wt board
1. 
	- VO: *. What are the limits in software? Hardware and Human*
	- OS: show memory full picture and human memory limit
1. 
	- VO: *Alright, so how would we create a near-physical theory of software*
	- OS: Big question mark
1. 
	- VO: *Before I tell you what I did with that thought, I should admit that I did a google search...*
	- OS: Google search pic
	- VO: *...and found a whole book - GUTSE*
	- OS: GUTSE cover
1. 
	- VO: *GUTSE in a nutshell*
	- OS: Overview pic for GUTSE
	- VO: *But it didnt have a detailed view of code - only a visual one, with human-acceptable proofs*
	- VO: *... so I decided to work on the detailed view - GUTS*
1. 
	- VO: *So what's a good physical equivalent - a model - for code?*
	- OS: Show one lego block, or stack of cards
	- VO: *Obviously a lego block is one stock example. it shows the sequence of steps, but it doesnt depict the flow of control*
1. 
	- VO: *So we could think of water or some liquid flowing through some pipes as a model*
	- OS: Picture of fluid circuit
	- VO: *If we squint, we could even visualize the data flowing through complex turbines and such components. In fact many museums have such systems on display. But this seems to imply that data is continuous, which in a modern vNM machine it is not*
1. 
	- VO: *...so that didnt seem quite right. When I looked around, there WAS one thing that DID seems like a good approximation of how code and data work together*
	- OS: Show picture of marble run
	- VO: *... the marble run. it has the code structure(the pieces), the ability to run data (marbles) and they are discrete. There's even some primitive logic*
	- OS: Show picture of logic piece or even actual object
1. 
	- VO: *... of course, what all of this is leading toward is the fact that we can treat code as a graph - certainly not a new idea - but the physical interpretation will help in analyzing code physically, as I'll show*
	- OS: show flowchart and one complex code dependency diagram.
1. 
	- VO: *.. before I do that, a quick sidebar into the grand vision*
	- OS: Show part of mindmap that has all properties in it
	- VO: << explain briefly what it is >>
1. 
	- VO: sdfsd
	- OS: sdfsd
